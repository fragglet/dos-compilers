///////////////////////////////////////////////////////////////////////////
// FILE: stack ()
//
// =========================================================================
//
//                          Open Watcom Project
//
// Copyright (c) 2004-2023 The Open Watcom Contributors. All Rights Reserved.
//
//    This file is automatically generated. Do not edit directly.
//
// =========================================================================
//
// Description: This header is part of the C++ standard library.
//              It defines the std::stack template adaptor
///////////////////////////////////////////////////////////////////////////
#ifndef _STACK_INCLUDED
#define _STACK_INCLUDED

#ifndef _ENABLE_AUTODEPEND
 #pragma read_only_file
#endif

#ifndef __cplusplus
 #error This header file requires C++
#endif

#ifndef _DEQUE_INCLUDED
 #include <deque>
#endif

namespace std {

/*===================================================================
 * stack template adaptor
 */
template< class Type, class Container = deque< Type > >
class stack{
public:
    typedef typename Container::value_type  value_type;
    typedef typename Container::size_type   size_type;
    typedef          Container              container_type;
protected:
    Container c;
public:
    explicit            stack( Container const & x = Container() ) : c( x ) {}
    bool                empty() const   { return( c.empty() ); }
    size_type           size()  const   { return( c.size() ); }
    value_type&         top()           { return( c.back() ); }
    value_type const &  top() const     { return( c.back() ); }
    void                push( value_type const & v )
                                        { c.push_back( v ); }
    void                pop()           { c.pop_back(); }

    bool                _Sane()         { return( c._Sane() ); }
};

template< class Type, class Container>
bool operator==( stack< Type, Container > const & x,
                 stack< Type, Container > const & y )
{
    return( x.c == y.c );
}

template< class Type, class Container>
bool operator!=( stack< Type, Container > const & x,
                 stack< Type, Container > const & y )
{
    return( x.c != y.c );
}

template< class Type, class Container>
bool operator<( stack< Type, Container > const & x,
                stack< Type, Container > const & y )
{
    return( x.c < y.c );
}

template< class Type, class Container>
bool operator>( stack< Type, Container > const & x,
                stack< Type, Container > const & y )
{
    return( x.c > y.c );
}

template< class Type, class Container>
bool operator>=( stack< Type, Container > const & x,
                 stack< Type, Container > const & y )
{
    return( x.c >= y.c );
}

template< class Type, class Container>
bool operator<=( stack< Type, Container > const & x,
                 stack< Type, Container > const & y )
{
    return( x.c <= y.c );
}

} // namespace std

#endif
