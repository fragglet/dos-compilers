///////////////////////////////////////////////////////////////////////////
// FILE: type_traits
//
// =========================================================================
//
//                          Open Watcom Project
//
// Copyright (c) 2004-2023 The Open Watcom Contributors. All Rights Reserved.
//
//    This file is automatically generated. Do not edit directly.
//
// =========================================================================
//
// Description: This header is part of the C++ standard library.
///////////////////////////////////////////////////////////////////////////
#ifndef _TYPE_TRAITS_INCLUDED
#define _TYPE_TRAITS_INCLUDED

#ifndef _ENABLE_AUTODEPEND
 #pragma read_only_file
#endif

#ifndef __cplusplus
 #error This header file requires C++
#endif

namespace std {

    template< class T, T v >
    struct integral_constant{
        static const T value = v;
        typedef T value_type;
        typedef integral_constant< T, v > type;
    };
    typedef integral_constant< bool, true >  true_type;
    typedef integral_constant< bool, false > false_type;


#define __MAKE_TYPE_TRAIT_DEFAULT( name, base ) \
    template < class T > struct name : public base { };

#define __MAKE_TYPE_TRAIT( name, type, base ) \
    template <> struct name< type > : public base { };

#define __MAKE_TYPE_TRAIT_MOD( name, modifer, base ) \
    template < class T > struct name< T modifer > : public base { };

#define __MAKE_TYPE_TRAITS_CV( name, type, base )       \
    __MAKE_TYPE_TRAIT( name, type, base )               \
    __MAKE_TYPE_TRAIT( name, type const, base )         \
    __MAKE_TYPE_TRAIT( name, type volatile, base )      \
    __MAKE_TYPE_TRAIT( name, type const volatile, base )

#define __MAKE_TYPE_TRAITS_MOD_CV( name, mod, base )    \
    __MAKE_TYPE_TRAIT_MOD( name, mod, base )            \
    __MAKE_TYPE_TRAIT_MOD( name, mod const, base )      \
    __MAKE_TYPE_TRAIT_MOD( name, mod volatile, base )   \
    __MAKE_TYPE_TRAIT_MOD( name, mod const volatile, base )

#define __MAKE_TYPE_TRAITS_CV_SUS( name, type, base )   \
    __MAKE_TYPE_TRAITS_CV( name, unsigned type, base )  \
    __MAKE_TYPE_TRAITS_CV( name, signed type, base )


    // ==================================================================
    // 4.5.1 primary type categories
    /* ------------------------------------------------------------------
     * is_void
     */
    __MAKE_TYPE_TRAIT_DEFAULT( is_void, false_type )
    __MAKE_TYPE_TRAITS_CV( is_void, void, true_type )

    /* ------------------------------------------------------------------
     * is_integral
     */
    __MAKE_TYPE_TRAIT_DEFAULT( is_integral, false_type )
    __MAKE_TYPE_TRAITS_CV_SUS( is_integral, int, true_type )
    __MAKE_TYPE_TRAITS_CV_SUS( is_integral, short, true_type )
    __MAKE_TYPE_TRAITS_CV_SUS( is_integral, long, true_type )
    __MAKE_TYPE_TRAITS_CV_SUS( is_integral, long long, true_type )
    __MAKE_TYPE_TRAITS_CV( is_integral, bool, true_type )
    __MAKE_TYPE_TRAITS_CV( is_integral, signed char, true_type )
    __MAKE_TYPE_TRAITS_CV( is_integral, unsigned char, true_type )
    __MAKE_TYPE_TRAITS_CV( is_integral, char, true_type )
    __MAKE_TYPE_TRAITS_CV( is_integral, wchar_t, true_type )


    /* ------------------------------------------------------------------
     * is_floating_point
     */
    __MAKE_TYPE_TRAIT_DEFAULT( is_floating_point, false_type )
    __MAKE_TYPE_TRAITS_CV( is_floating_point, float, true_type )
    __MAKE_TYPE_TRAITS_CV( is_floating_point, double, true_type )
    __MAKE_TYPE_TRAITS_CV( is_floating_point, long double, true_type )

    /* ------------------------------------------------------------------
     * is_pointer
     */
    __MAKE_TYPE_TRAIT_DEFAULT( is_pointer, false_type )
    __MAKE_TYPE_TRAITS_MOD_CV( is_pointer, *, true_type )

    /* ------------------------------------------------------------------
     * is_reference
     */
    __MAKE_TYPE_TRAIT_DEFAULT( is_reference, false_type )
    __MAKE_TYPE_TRAITS_MOD_CV( is_reference, &, true_type )

    /*
     * Will these need compiler support?

     template <class T>
     struct is_member_object_pointer;
     template <class T>
     struct is_member_function_pointer;
     template <class T>
     struct is_enum;
     template <class T>
     struct is_union;
     template <class T>
     struct is_class;
     template <class T>
     struct is_function;
    */

    // ==================================================================
    // 4.5.2 composite type traits
    /* ------------------------------------------------------------------
     * is_arithmetic
     */
    template < class T >
    struct is_arithmetic : public integral_constant< bool,
                                                     is_integral< T >::value ||
                                                     is_floating_point< T >::value > { };

    /* ------------------------------------------------------------------
     * is_fundamental
     */
    template < class T >
    struct is_fundamental : public integral_constant< bool,
                                                      is_integral< T >::value ||
                                                      is_floating_point< T >::value ||
                                                      is_void< T >::value > { };
    /*
      template <class T>
      struct is_object;
      template <class T>
      struct is_scalar;
      template <class T>
      struct is_compound;
      template <class T>
      struct is_member_pointer;
    */

    // ==================================================================
    // 4.5.3 type properties
    /* ------------------------------------------------------------------
     * is_const
     */
    __MAKE_TYPE_TRAIT_DEFAULT( is_const, false_type )
    __MAKE_TYPE_TRAIT_MOD( is_const, const, true_type )

    /* ------------------------------------------------------------------
     * is_volatile
     */
    __MAKE_TYPE_TRAIT_DEFAULT( is_volatile, false_type )
    __MAKE_TYPE_TRAIT_MOD( is_volatile, volatile, true_type )

    /*
      template <class T> struct is_pod;
      template <class T> struct is_empty;
      template <class T> struct is_polymorphic;
      template <class T> struct is_abstract;
      template <class T> struct has_trivial_constructor;
      template <class T> struct has_trivial_copy;
      template <class T> struct has_trivial_assign;
      template <class T> struct has_trivial_destructor;
      template <class T> struct has_nothrow_constructor;
      template <class T> struct has_nothrow_copy;
      template <class T> struct has_nothrow_assign;
      template <class T> struct has_virtual_destructor;
      template <class T> struct is_signed;
      template <class T> struct is_unsigned;
      template <class T> struct alignment_of;
      template <class T> struct rank;
      template <class T, unsigned I = 0> struct extent;
    */

    // ==================================================================
    // 4.6 type relations
    /* ------------------------------------------------------------------
     * is_same
     */
    template < class T, class U > struct is_same : public false_type {};
    template < class T > struct is_same< T, T > : public true_type {};
    /*
      template <class Base, class Derived> struct is_base_of;
      template <class From, class To> struct is_convertible;
    */

    // ==================================================================
    // 4.7.1 const-volatile modifications
    /* ------------------------------------------------------------------
     * remove_const
     */
    template< typename T >
    struct remove_const { typedef T type; };

    template< typename T >
    struct remove_const< T const > { typedef T type; };

    /* ------------------------------------------------------------------
     * remove_volatile
     */
    template< typename T >
    struct remove_volatile { typedef T type; };

    template< typename T >
    struct remove_volatile< T volatile > { typedef T type; };

    /* ------------------------------------------------------------------
     * remove_cv
     */
    template< typename T >
    struct remove_cv {
        typedef remove_volatile< remove_const< T >::type >::type type;
    };

    /* ------------------------------------------------------------------
     * add_const
     */
    template< typename T >
    struct add_const { typedef T const type; };

    /* ------------------------------------------------------------------
     * add_volatile
     */
    template< typename T >
    struct add_volatile { typedef T volatile type; };

    /* ------------------------------------------------------------------
     * add_cv
     */
    template< typename T >
    struct add_cv { typedef T const volatile type; };

    // ==================================================================
    // 4.7.2 reference modifications
    /* ------------------------------------------------------------------
     * remove_reference
     */
    template< typename T >
    struct remove_reference { typedef T type; };

    template< typename T >
    struct remove_reference< T& > { typedef T type; };

    template< typename T >
    struct remove_reference< T& const > { typedef T type; };

    template< typename T >
    struct remove_reference< T& volatile > { typedef T type; };

    template< typename T >
    struct remove_reference< T& const volatile > { typedef T type; };

    /* ------------------------------------------------------------------
     * add_reference
     */
    template< typename T >
    struct add_reference { typedef T& type; };

    template< typename T >
    struct add_reference< T& > { typedef T& type; };

    template< typename T >
    struct add_reference< T& const > { typedef T& const type; };

    template< typename T >
    struct add_reference< T& volatile > { typedef T& volatile type; };

    template< typename T >
    struct add_reference< T& const volatile > { typedef T& const volatile type; };

    // ==================================================================
    // 4.7.3 array modifications
    /*
      template <class T> struct remove_extent;
      template <class T> struct remove_all_extents;
    */

    // ==================================================================
    // 4.7.4 pointer modifications
    /* ------------------------------------------------------------------
     * remove_pointer
     */
    template< typename T >
    struct remove_pointer { typedef T type; };

    template< typename T >
    struct remove_pointer< T* > { typedef T type; };

    template< typename T >
    struct remove_pointer< T* const > { typedef T type; };

    template< typename T >
    struct remove_pointer< T* volatile > { typedef T type; };

    template< typename T >
    struct remove_pointer< T* const volatile > { typedef T type; };

    /*
      template <class T> struct add_pointer;
    */

    // ==================================================================
    // 4.8 other transformations
    /*
      template <size_t Len, size_t Align> struct aligned_storage;
    */

} // namespace std

#endif
